\documentclass[parskip=full]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\hypersetup{
	pdftitle={PSE: Blockchain-basiertes E-Voting - Implementierungsbericht},%
	,%
}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage[nonumberlist]{glossaries}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{svg}
\usepackage[section]{placeins}

\makeatletter
\AtBeginDocument{%
	\expandafter\renewcommand\expandafter\subsection\expandafter{%
		\expandafter\@fb@secFB\subsection
	}%
}
\makeatother
\makeatletter
\AtBeginDocument{%
	\expandafter\renewcommand\expandafter\subsubsection\expandafter{%
		\expandafter\@fb@secFB\subsubsection
	}%
}
\makeatother

\addto\extrasngerman{\def\figureautorefname{Abb.}}
\newcommand{\textitx}[1]{\mbox{\textit{#1}}}
\newcommand{\fakeparagraph}[1]{\textbf{#1}}
%\renewcommand{\includesvg}[1][1]{}


\title{
	PSE:Blockchain-basiertes E-Voting \\
	Implementierungsbericht
}
\author{Tim Fröhlich, Achim Kriso, Philipp Schaback, David Schuldes, Artem Vasilev\\ Phasenverantwortlicher: Philipp Schaback}



\begin{document}
\clearpage
\maketitle
\pagenumbering{gobble}
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Einleitung}
Dieses Dokument beschreibt die Ergebnisse der Implementierungsphase, die
im Rahmen des Moduls Praxis der Softwareentwicklung (PSE) am Lehrstuhl „Anwendungsorientierte formale Verifikation" von Prof. Dr. Beckert am Karlsruher Institut für
Technologie entstanden sind.
Implementiert wurde die im Pflichtenheft vorgegebene und in der Entwurfsphase entworfene Software "Blockchain-basiertes Evoting".


\section{Zeitablauf}
Um einen schnellen und erfolgreichen Abschluss der Implementierung zu begünstigen, begann diese bereits Ende Juni.
Die im Entwurfsdokument angegebene Zeiteinschätzung wurde hierbei weitestgehend eingehalten, in vorteilhaft gestauchter Version (siehe \autoref{fig:gantt}).
\begin{figure}[h!]
	\centering\includegraphics[width=\textwidth]{pictures/Gantt.pdf}
	\caption{Gantt-Diagramm (unvollständig)}
	\label{fig:gantt}
\end{figure}


\section{Umsetzung der funktionalen Anforderungen}

\subsection{Musskriterien}
Alle im Pflichtenheft festgelegten Musskriterien werden durch die Implementierung umgesetzt.

\subsection{Sollkriterien}
Die Sollkriterien wurden alle bis auf eines erfüllt:
\textit{S3: Dynamische Peerverbindung}\\
Teil des Sicherheitsmodells von Hyperledger Fabric ist, dass ein Client Verbindungen zu mehreren Peers herstellt, das Kriterium sieht aber nur die Verbindung zu einem Peer vor.
Somit wäre eine Umsetzung von S3 der korrekten und sicheren Wahl entgegenstehend. Dennoch ermöglichen wir es, einzelne Peers mittels der Konfigurationsdatei auszuschließen.  

\subsection{Kannkriterien}
Alle Kannkriterien, ausgenommen von \textit{K2: Geheime Wahlen} wurden umgesetzt. Die Implementierung von geheimen Wahlen zeigte sich bei unseren Nachforschungen als besonders aufwändig, da der Ledger grundsätzlich \enquote{by design} öffentlich ist. Mögliche Strategien wie das Verschlüsseln der Stimmen beim Wähler und späteres Entschlüsseln wurden als Lösung in Betracht gezogen. Selbst hiermit erweist sich die Umsetzung als problematisch, da die Auswertung der Stimmen vom Klienten in die Smart Contracts verlegt werden müsste, um wahrhaft geheim zu sein. Eine solche Auszählung wird durch die verschiedenen Wahlsysteme und deren unterschiedliche Auszählungsverfahren zusätzlich erschwert. Es wäre nur schwer nachzuverfolgen, welcher Chaincode tatsächlich eingesetzt wird. Im Gegensatz dazu könnte beispielsweise der Source Code des Klienten offengelegt werden und ein solcher Wähler könnte nachvollziehen, dass die Auswertung korrekt vonstatten ging.

\section{Umsetzung der nichtfunktionalen-Anforderungen}

Alle im Pflichtenheft definierten, nicht-funktionale Anforderung wurden erfüllt. Im Folgenden sind sie in die Kategorien Zeitverhalten und Benutzerfreundlichkeit unterteilt.

\subsection{Zeitverhalten}

\begin{itemize}
	\item Die Stimmabgabe eines Wählers dauert vorraussichtlich nicht länger als 5 Minuten.
	\item Die grafische Benutzeroberfläche reagiert sofort entsprechend der Aktion des Benutzers.
	\item Die Auswertung einer Wahl nimmt bei höchstens 10000 abgegebenen Stimmen vorraussichtlich nicht mehr als 5 Minuten in Anspruch.
\end{itemize}

\subsection{Benutzerfreundlichkeit}
\begin{itemize}
	\item Die Benutzung der Software erfordert keine besonderen Vorkenntnisse, so dass sie auch Benutzer mit geringen Computerkenntnissen verwenden können.
\end{itemize}

\section{Produktleistungen}
Erfolgreich abgegebene Stimmen gehen unverfälscht in die Auswertung der Wahl ein und werden genau einmal gewertet. Es ist nicht möglich, Stimmabgaben zu verfälschen und somit das Ergebnis der Wahlauswertung zu manipulieren.
		
\section{Umsetzung von Entwurfsentscheidungen}
\subsection{Model-View-Control Architektur}
Bei der Implementierung wurden alle Pakete und Schnittstellen unter Einhaltung der in der in der Entwurfsphase modellierten Model-View-Control Architektur implementiert. Die Architektur sorgt für eine hohe Modularität der einzelnen Komponenten. Sie können problemlos unter Einhaltung der nach außen angebotenen Schnittstellen ausgetauscht und erweitert werden. 

\subsection{Strategie-Entwurfsmuster}
Im StateManagement-Paket wurde das Strategie-Entwurfsmuster in den Klassen IRVVoting, AbsoluteMajorityVoting und RelativeMajorityVoting bei der Implementierung von determineWinner() benutzt.
Die Auszählung der Stimmen ist abhängig von der festgelegten Wahlform und erfolgt mithilfe der determineWinner()-Methode, die in jeweils in den zuvor genannten Klassen implementiert ist.
determineWinner() führt den Algorithmus zur Wahlauswertung aus. Deswegen finden sich in den Klassen IRVVotingSystem, RelativeMajorityVotingSystem und AbsoluteMajorityVotingSystem jeweils unterschiedliche Implementierungen der benötigten Variante des Auszählungsalgorithmus.
Der Vorteil hierbei ist, dass der Auszählungsalgorithmus modular gekapselt und austauschbar ist. Es können weitere Auszählungsverfahren hinzugefügt werden, ohne dass zusätzliche Anpassungen in anderen Klassen vorgenommen werden müssen.

\section{Änderungen zum Entwurf}
\paragraph{Interfaces}
Die Argumente und Rückgabetypen aller Interfaces wurden zu Beginn der Implementierung besser aufeinander abgestimmt um Inkonsistenzen zu entfernen.

\subsection{SDKConnection}

\paragraph{SDKConnectionImpl}
Die Klasse \textit{SDKConnectionImpl} wurde von einem normalen Konstruktor auf eine Fabrikmethode (\textit{getInstance()}) umgestellt, da Java \textit{super} als ersten Aufruf im Konstruktor erzwingt, und dies nicht mit dem Entwurf vereinbar war.

\subsection{View}

\paragraph{InformationPanel}
In der SupervisorView als auch in der VoterView werden die allgemeinen Informationen einer Wahl in einem \textit{JPanel} angezeigt. Um die Konfiguration dieses \textit{JPanel} zu vermeiden wurde die Implementation in die \textit{InformationPanel} Klasse ausgelagert, welche von der SupervisorView und der \textit{VoterView} verwendet wird. 

\paragraph{SupervisorVSComponentManager}
In \textit{SupervisorVSComponentManager} wurde die Methode \textit{updateResults()} hinzugefügt, um die von \textit{SupervisorVSComponentManager} generierten Komponenten mit neueren Ergebnisse zu aktualisieren.

\paragraph{ActiveListener}
Die \textit{VerticalTabs} Klasse benachrichtigt ihre enthaltenen \textit{JPanel}, mithilfe von der neuen Klasse \textit{ActiveListener}, welcher Tab gerade ausgewählt wurde. Diese Funktionalität wird benötigt damit die Konfiguration überprüft werden kann, wenn der Benutzer sich die Übersicht seiner Konfiguration darstellen lässt. 

\paragraph{GapExtension}
Es wurde die \textit{GapExtension} Klasse hinzugefügt. Diese Klasse ermöglicht es in Tabellen eine Lücke einzufügen.

\paragraph{ListExtensions}
Um einheitliche Schriftarten in der View zu ermöglichen, nehmen die \textit{ListExtension}-Konstruktoren eine Instanz von \textit{Font}.
\\
\\
Außerdem bekamen \textit{TextExtension}, \textit{TextFieldExtension} und \textit{DescriptionExtension} eine \textit{setText()} Methode, \textit{TextFieldExtension} und \textit{DescriptionExtension} eine \textit{setEditable()} Methode, mit welchen sich das Wahlformular des Wählers gleichzeitig zum Anzeigen seiner Stimme verwenden lässt.

\paragraph{BasicList}
Diese Klasse wurde um die \textit{setBorder()} Setter erweitert. Mit dieser Methode kann man den Rand einer Liste ändern und (besonders für unseren Zweck) deaktivieren.


%TODO: Controller
%TODO: StateManagement

\end{document}

