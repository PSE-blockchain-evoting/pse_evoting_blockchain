\documentclass[parskip=full]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\hypersetup{
pdftitle={PSE: Blockchain-basiertes E-Voting - Entwurfsdokument},%
,%
}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage[nonumberlist]{glossaries}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{rotating}
\usepackage{svg}
\usepackage[section]{placeins}
\makeatletter
\AtBeginDocument{%
	\expandafter\renewcommand\expandafter\subsection\expandafter{%
		\expandafter\@fb@secFB\subsection
	}%
}
\makeatother
\makeatletter
\AtBeginDocument{%
	\expandafter\renewcommand\expandafter\subsubsection\expandafter{%
		\expandafter\@fb@secFB\subsubsection
	}%
}
\makeatother

\addto\extrasngerman{\def\figureautorefname{Abb.}}
\newcommand{\textitx}[1]{\mbox{\textit{#1}}}
\newcommand{\fakeparagraph}[1]{\textbf{#1}}
%\renewcommand{\includesvg}[1][1]{}

\title{PSE: Blockchain-basiertes E-Voting}

\begin{document}
	\clearpage
	\maketitle
	\pagenumbering{gobble}
	\newpage
	
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\section{Einleitung}
	Dieses Dokument beschreibt die Ergebnisse der Entwurfsphase im Rahmen des Moduls Praxis der Softwareentwicklung (PSE) am Karlsruher Institut für Technologie, das am Lehrstuhl für Anwendungsorientierte formale Verifikation von Professor Beckert ausgeschrieben wurde.
	Entworfen wurde die im Pflichtenheft definierte Software "Blockchain E-voting". 
	
	Ziel der Software ist es, die Manipulation
	von Wahlergebnissen zu verhindern und den Wählern zu gewährleisten, dass ihre Stimme unverändert in die Wahl eingegangen ist.
	Ziel dieses Dokumentes ist es, zu erläutern wie die im Pflichtenheft spezifizierten Anforderungen softwaretechnisch umgesetzt werden sollen.
	
	\section{Architektur}
	\begin{figure}[!h]
	\centering
	\includesvg[width=\textwidth]{pictures/PackageDiagram.svg}
	\caption{Übersicht der Pakete und deren Interaktion}
	\end{figure}

	Basierend auf der Model-View-Control Architektur ist die Software in ein Model Paket, View Paket und Control Paket unterteilt und jede Assoziation zwischen den Paketen durch eine Schnittstelle klar definiert. 
	\\
	Das Projekt bietet zwei Klienten. Einen Wahlleiter Klient und einen Wähler Klient. Da diese beiden Klienten trotz fundamentaler Unterschiede viele gemeinsame Funktionen bieten sind die Schnittstellen in drei Interfaces unterteilt. Ein Interface welches die Gemeinsamkeiten der beiden Klienten erfasst und jeweils ein Interface für jeden Klienten der das allgemeine Interface um die benötigte Funktionalität erweitert. Dabei spiegelt der Name des Interfaces eine unidirektionale Assoziation zwischen den Paketen die es repräsentiert wider. Beispielsweise \textit{ControlToViewIF} ist das Interface das das Control Paket benutzt um auf Funktionalität des View Pakets zuzugreifen.
	\\
	Das View und Control Paket stehen in einer bidirektionalen Assoziation zueinander. Die Beiden Pakete haben außerdem eine Unidirektionale Assoziation zu dem Model Paket. Die einzige Ausnahme zu diesem System an Schnittstellen ist ein Callback Listener der von dem Model benutzt wird um das View Paket auf das Ende der Wahl zu benachrichtigen und von dem Blockchain Netzwerk ausgeht.
	\\
	\begin{itemize}
		\item[View:] Dieses Paket dient zur Darstellung der Benutzeroberfläche und benutzt das Java Swing GUI Framework für die Darstellung der einzelnen GUI Elemente. Außerdem enthält das Paket eine Reihe an eigenen Elementen, die für speziellere Anforderungen dieses Projektes konstruiert wurden. Unterschiede zwischen den beiden Klienten finden sich vor allem in der Darstellung der Benutzeroberflächen, deswegen sind sie in zwei Unterpakete unterteilt.
		\item[Control:] Der Controller nutzt die vom Java Swing Framework gebotenen Listener, die vom Control Paket an das View Paket weitergeleitet werden, um direkt auf Benutzereingaben einzugehen. Sobald Control eine Eingabe empfängt werden Aufgaben abhängig davon welcher Listener ausgelöst wurde über die Schnittstellen an das Model oder View Paket weitergeleitet. Wie das View Paket ist auch das Control Paket in ein Subpaket für den Wahlleiter und ein Subpaket für den Wähler unterteilt. Die Subpakete enthalten jeweils eine spezielle Implementierung des \textit{ViewToControl} interfaces und alle benötigten Listener.
		\item[Model:] Das Model Paket hat zwei Hauptaufgaben. Es verwaltet alle zustandsrelevanten Daten und hält die Schnittstelle zu dem Blockchain Netzwerk über die vom Hyperledger Framework gebotenen Schnittstellen. Diese zwei Aufgaben sind in zwei Subpakete unterteilt. Das SDKConnection Paket, welche die sehr Allgemeinen Schnittstellen des Hyperledger Frameworks auf die Anforderungen der Software anpasst, und das StateManagement Paket welches alle Daten bereitstellt und deren interne Logik enthält.   
	\end{itemize} 
	
	\newpage
	\section{Model}
	Die zwei Subpakete in Model kommunizieren über die definierte Schnittstelle \textit{SDKInterface} und einen Callback Listener \textit{SDKEventListener}. 
	Damit der Klient darüber informiert ist, ob die Wahl noch läuft wird der \textit{SDKEventListener} benutzt. Ein Klient kann über die Schnittstellenmethode dispatchElectionOverCheck() eine Überprüfung auf der Blockchain Anforderung, die herausfindet ob die Wahl geendet hat. Wenn das der Fall ist wird der die Methode onElectionEnd() in jedem Klienten aufgerufen. Wenn die Wahl noch nicht zuende ist wird onElectionRunning() in jedem Klienten aufgerufen. Dieses System wird benutzt um unnötige dispatchElectionOverCheck() Aufrufe zu vermeiden. Jeder Klient überprüft, mithilfe eines Threads, wann das letzte mal onElectionRunning() aufgerufen wurde. Wenn dies Länger als die backoff Zeit in Minuten her ist, ruft der Klient selber dispatchElectionOverCheck() auf. Um zu verhindern das alle Klienten zum gleichen Zeitpunkt dispatchElectionOverCheck() aufrufen, wird die backoff Zeit in jedem Klienten zufällig in in einem Zeitraum gewählt. Sobald einmal onElectionOver() aufgerufen wurde, muss der Thread nie wieder dispatchElectionOverCheck() aufrufen und er setzt hasEnded auf wahr und beendet sich.
	Die Schnittstelle ist wieder in drei Interfaces unterteilt. Eine für die Gemeinsamkeiten (\textit{SDKInterface}) der beiden Klienten und jeweils eine für die Unterschiede (\textit{SupervisorSDKInterface} und \textit{VoterSDKInterface}).

	\subsection{Paket: StateManagement}
	Das StateManagement Paket hat die Aufgabe alle wichtigen Zustandsdaten zu speichern, für die View zugänglich und die Logik der Daten zu implementieren.
	Dabei kommuniziert es mit dem SDKConnection Paket um Daten von der Blockchain zu holen und Aktionen auf der Blockchain auszuführen.
	
		\subsubsection{Election}
		Im Zentrum dieses Paketes ist die \textit{Election} Klasse. Sie speichert die Kandidaten, Stimmen und Allgemeine Wahldaten in Form des \textit{ElectionDataIF}. Außerdem hält es den SDKEventListener um über den Zustand der, auf 
		der Blockchain, laufenden Wahl informiert zu werden.\\
		Die \textit{Election} Klasse wird erweitert durch ...
		\begin{itemize}
			\item\textit{SupervisorElection} um die nötige Funktionalität für den Wahlleiter hinzuzufügen. Dies beeinhaltet alle Wähler und eine Assoziation zu \textit{SupervisorSDKInterface}.
			\item\textit{VoterElection} in der der Wähler seine eigene Stimme speichert und eine Assoziation zu \textit{VoterSDKInterface} hat.
		\end{itemize}
		
		\subsubsection{VotingSystem}
		Das benutzte Wahlsystem einer Wahl hat einen breiten Einfluss darauf wie sich das System verhält. Im StateManagement Paket bestimmt es welche Art von Stimme benutzt wird und wie der Gewinner ermittelt wird.
		Um diese Funktionen Objekt Orientiert umzusetzen existiert die abstrakte Klasse \textit{VotingSystem}. Sie setzt voraus, dass alle Implementationen eine loadVote(vote : String) Methode und determineWinner() Methode implementieren. Die erste Methode dient dazu Stimmen die in Form eines String vorliegen in Vote Objekte umgewandelt werden. determineWinner() evaluiert alle gespeicherten Stimme in dem \textit{Election} Objekt und bestimmt welcher Kandidat gewonnen hat.
		Da beim Start eines Klienten das Wahlsystem nur als String vorliegt (entweder von der Blockchain geladen oder in der Konfigurationbenutzeroberläche eingegeben), wird die Klasse \textit{VotingSystemGenerator} benutzt um diesen String in ein \textit{VotingSystem} Objekt konvertieren.
		Zur Vereinfachung der Implementation von \textit{VotingSystem} haben \textit{Vote} Klassen eine asString() Methode welche ihren Zustand in einen String umwandeln. Solche Strings können durch die statische Methode loadVote(vote : String) wieder in ein äquivalentes Vote Objekt umgewandelt werden.

	
	\subsection{Paket: SDKConnection}
	\subsubsection{Übersicht}
	Das Paket \textit{SDKConnection} stellt die Verbindung der Software zum \textit{Hyperledger Fabric SDK} und \textit{Hyperledger Fabric CA SDK} dar. Diese SDKs übernehmen ihrerseits die Kommunikation mit dem Netzwerk. \textit{SDKConnection} ist Teil des \textit{Models}.
	\subsubsection{Wichtige Elemente der SDKConnection}
	\paragraph{SDKInterfaceImpl} ist eine Implementierung der generische Schnittstelle \textit{SDKInterface}. Sie wird erweitert durch die klientspezifischen Implementierungen \textit{SupervisorSDKInterfaceImpl} und \textit{VoterSDKInterfaceImpl}. Sie bietet Zugriff auf die von beiden Klienten gemeinsam genutzen Funktionen, beispielsweise zur Popularisierung der Benutzeroberfläche mit Wahlinformationen nach einem Neustart derselbigen.
	\paragraph{SupervisorSDKInterfaceImpl} ist eine Implementierung der Schnittstelle \textit{SupervisorSDKInterface}. Sie bietet die zum Wahlleiter-Klienten spezifische Kommunikation mit dem SDK zum Erstellen und endgültigen Beenden der Wahl. Außerdem ermöglicht sie das Auslesen aller bisherigen Stimmen aus dem Ledger und das Erstellen neuer Benutzer.
	\paragraph{VoterSDKInterfaceImpl} ist eine Implementierung der Schnittstelle \textit{VoterSDKInterface}. Sie bietet die zum Wähler-Klienten spezifische Kommunikation mit dem SDK, zum Abgeben einer Stimme und Auslesen der eigenen Stimme aus dem Ledger.
	\paragraph{AppUser} repräsentiert eine Person aus der Sicht des SDKs. Die Klasse realisiert die Schnittstellen \textit{User} des Hyperledger SDKs und \textit{Serializable} des Java SDKs. \textit{SupervisorSDKInterfaceImpl} erstellt Objekte dieses Typs und serialisiert sie zur Weitergabe an die Wähler.
	\paragraph{Transactions} (siehe \autoref{fig:sdk_transaction}) kapselt die verschiedenen Transaktionen die mittels des SDKs zum Netzwerk gesendet werden können. Die Methoden der \textit{*SDKInterfaceImpl} benutzen jeweils einer dieser Klassen als Kapselung einer Anfrage. Sie werden grundsätzlich in zwei Kategorie aufgeteilt:
	\begin{enumerate}
			\item\fakeparagraph{QueryTransaction}: Transaktionen, die nur Daten anfragen, aber keine Änderungen am Datenbestand des Ledgers vornehmen. Zwischen \textit{QueryTransaction} und den eigentlichen Queries liegen verschiedene abstrakte Klassen, die das Parsen der Rückgabe für die verschiedene Rückgabetypen übernehmen.
			\begin{itemize}
				\item \fakeparagraph{AllVotesQuery}: Gibt alle Stimmen zur Auswertung zurück.
				\item \fakeparagraph{OwnVoteQuery}: Gibt die Stimme des \textit{AppUsers} zurück.
				\item \fakeparagraph{ElectionDataQuery}: Gibt alle Metadaten der Wahl zurück.
			\end{itemize}
			\item \fakeparagraph{InvokeTransaction}: Transaktionen, die Änderungen am Datenbestand des Ledgers vornehmen, aber keine Daten zurückgeben. Die Konstruktoren dieser Klassen wandeln die übergeben Parameter in ein JSON-String um, welcher dann in \textitx{InvokeTransaction.invoke} an das SDK übergeben wird.
			\begin{itemize}
				\item \fakeparagraph{VoteInvocation}: Gibt die Stimme des \textit{AppUsers} ab.
				\item \fakeparagraph{InitializationInvocation}: Initialisiert die Wahl auf dem Ledger
				\item \fakeparagraph{ElectionStatusUpdateInvocation}: Löst ein Update-Event im Chaincode aus, welches von allen \textit{ElectionStatusListenern} empfangen wird.
				\item \fakeparagraph{DestructionInvocation}: Startet das Netzwerk neu, um die Wahl endgültig zu beenden.
			\end{itemize}
	\end{enumerate}
	\newpage
	\begin{sidewaysfigure}[!h]
		\centering
		\hspace{-100pt}
		\centerline{\includesvg[width=1.3\textwidth]{pictures/Transactions}}
		\caption{Das Transactions-Paket}
		\label{fig:sdk_transaction}
	\end{sidewaysfigure}
	\thispagestyle{empty}
	\subsubsection{Typische Abläufe aus Sicht von SDkConnection}
	Im Nachfolgenden sollen typische Abläufe aus der Sicht von SDKConnection beschrieben werden, diese sind Teil aller im Pflichtenheft beschrieben Testfallszenarien. Sie erfüllen außerdem Teile der funktionalen Anforderungen \textbf{F1, F2, F3, F4, F6, F8, F16} \\ \\ 
	% Nennung der Anforderungen beibehalten?
	Zuallererst registriert sich der Wahlleiter im Netzwerk (siehe \autoref{fig:sdk_first_registration}). Dazu erstellt das StateManagement eine Instanz von \textit{SupervisorSDKInterfaceImpl} und übermittelt dieser den Bootstrap-Username und das Bootstrap-Passwort welche aus der Konfigurationsdatei gelesen wird. Diese wiederum erstellt eine Instanz von \textit{HFCAClient}, der Hyperledger Fabric CA Schnittstelle, um die Identität des Wahlleiters (Admins, aus der Sicht des SDKs) zu registrieren. Mit dieser Identität (\textit{Enrollment}) wird ein AppUser erstellt, welcher serialisiert und im mitgegebenen Dateipfad abgespeichert wird.\\ \\
	Als nächstes fügt das StateManagement die Wähler hinzu (siehe \autoref{fig:sdk_adding_voters}). Dazu ruft es die Methode \textit{createUser} für jeden User auf, welche einen \textit{RegistrationRequest} anlegt und mit diesem eine Identität beim \textit{HFCAClient} registriert. Der damit gebaute \textit{AppUser} wird serialisiert an den übergebenen Dateipfad geschrieben. Diese Dateien sind die Zertifikate, die an die Wähler verteilt werden müssen. \\ \\
	Dann werden die Wahldaten (\textit{ElectionDataInterface}) festgelegt, hierzu dient die Methode \textit{createElection} (siehe \autoref{fig:sdk_creating_election}). Diese erstellt die entsprechende Transaktion aus dem Transaction-Paket, \textit{InitializationInvocation}, welche wiederum die übermittelten Wahldaten in einen JSON-String verpackt. Mit der Methode \textit{invoke} wird die Transaktion ans SDK und von diesem an das Netzwerk gesendet.
	Damit ist das Erstellen einer Wahl aus der Sicht von \textit{SDKConnection} abgeschlossen.
	
	\newpage
	\pagestyle{empty}
	\begin{sidewaysfigure}[!h]
		\centering
		\hspace{-100pt}
		\centerline{\includesvg[width=1.3\textwidth]{pictures/Authentication}}
		\caption{Erste Anmeldung des Wahlleiters im Netzwerk}
		\label{fig:sdk_first_registration}
	\end{sidewaysfigure}
	\newpage
	\begin{sidewaysfigure}[!h]
		\centering
		\hspace{-100pt}
		\centerline{\includesvg[width=1.3\textwidth]{pictures/AddingUsers}}
		\caption{Hinzufügen von neuen Wählern durch den Wahlleiter}
		\label{fig:sdk_adding_voters}
	\end{sidewaysfigure}
	\newpage
	\begin{sidewaysfigure}[!h]
		\centering
		\hspace{-100pt}
		\centerline{\includesvg[width=1.3\textwidth]{pictures/CreatingElection}}
		\caption{Erstellen einer Wahl durch den Wahlleiter}
		\label{fig:sdk_creating_election}
	\end{sidewaysfigure}
	\newpage

	\section{View}
	\pagestyle{headings}	
		\subsection{Components}
		Dieses Unterpaket stellt dem Rest des View Paketes Diagramme und ein modulares Tabellen System bereit.
		
		\subsubsection{Diagramme}
		\subsubsection{Tabellen}
		\begin{figure}[!h]
			\centering
			\includesvg[width=\textwidth]{pictures/DiagramClassDiagram.svg}
			\caption{Klassendiagram der Diagramme}
		\end{figure}
		
		Diagramme werden vom View Paket benötigt, um die Ergebnisse einer Wahl in einer Benutzerfreundlichen Form darzustellen. Da die verschiedene Wahlsysteme jedoch nur unterschiedliche Visualisierungen Sinn machen ist es nötig eine Allgemeine Diagramm Schnittstelle zu bieten. Diese Schnittstelle ermöglicht es dem Diagramm die benötigten Daten entgegenzunehmen und durch die Java Swing Graphics Schnittstelle die in der Schablonenmethode drawChart(g : Graphics) überreicht wird zu zeichnen. Es ist jeder Implementation dieser Schnittstelle überlassen wie diese Daten zu interpretieren sind. Um die im Pflichtenheft beschriebenen Wahlsysteme zu unterstützen, existieren die Implementationen \textit{PieChart} und \textit{StackedBarChart}.
		
		\subsubsection{Tabellen}
		\begin{figure}[!h]
		\centering
		\includesvg[width=\textwidth]{pictures/ListExtensionClassDiagram.svg}
		\caption{Klassendiagram des Tabellensystems}
		\end{figure}
		
		Tabellen mit unterschiedlicher Struktur und Funktionalität werden in verschieden Bereichen der View benötigt (beispielsweise Wahlkonfiguration, Stimmabgabe und Ergebniseinsicht). Um redundanten UI Quellcode zu vermeiden wurde eine erweiterbare Tabelle entworfen, welche aus Verschiedenen Modulen (Erweiterungen) besteht mit denen sich alle bestehenden Anforderungen dieses Projektes erfüllen lassen.
		\\
		Grundlegend ist eine Liste von Einträgen. Jeder Eintrag ist grundsätzlich gleich aufgebaut (besteht aus den gleichen Komponenten). Ein Eintrag ist durch die Klasse \textit{Entry} modelliert. Die Klasse \textit{BasicList} implementiert das grundlegende Verhalten einer Liste. Dieses erfasst die Möglichkeit durch die Tabelle zu scrollen, wenn sie nicht ganz in ihren Bereich passt und bietet die normale Schnittstelle einer jeden anderen Java Swing Komponente damit sie von dem Framework ohne Schwierigkeiten in die GUI integriert werden kann.
		\\
		Die Modularität dieses Tabellen Systems wird durch die Klasse \textit{ExtendableList} implementiert. Diese Klasse ist eine Erweiterung von \textit{BasicList}. Objekte die eine Instanz von \textit{ListExtension} sind können durch den Konstruktor von \textit{ExtendableList} zu der Tabelle hinzugefügt werden. Erweiterungen sind mithilfe des Dekorierer Entwurfsmusters umgesetzt. Sie werden miteinander verknüpft, indem jede Erweiterung eine andere durch ihren Konstruktor bekommen kann. Diese Kette an Erweiterungen wird schließlich dem Konstruktor der \textit{ExtendableList} überreicht der die von den Erweiterungen ausgehende Funktionalität umsetzen kann. Die Schnittstelle \textit{ListExtension} benachrichtigt jede Erweiterung wenn sich etwas in der Tabelle ändert (ein Eintrag wird entfernt oder hinzugefügt). Wenn ein neuer Eintrag hinzugefügt (addEntry(e : Entry)) wird, wird ein leeres Objekt vom Typ \textit{Entry} durch die Kette der Erweiterungen gereicht und jeder Erweiterung die Möglichkeit geboten eigene Java Swing Komponenten auf diesem Eintrag zu platzieren. Sobald dieser Eintrag durch die komplette Kette gewandert ist, wird er in der Tabelle platziert. Es ist die Aufgabe jeder Erweiterung ihre Komponenten selber zu verwalten, da die eigentliche Tabelle diese nicht kennt. Da viele Tabellen Erweiterungen nur eine Komponente zu einem Eintrag hinzufügen ist diese spezielle Funktionalität in der Klasse \textit{ComponentExtension} implementiert. Sie bietet außerdem eigene Schablonenmethoden über welche die Implementation starken Einfluss auf das konkrete Verhalten dieser Komponente nehmen können. Die Schablonenmethode newType() erlaubt der Implementation konkret zu bestimmen genaue welche Komponente zu dem nächsten Entry hinzugefügt werden soll. removeData() löscht die Komponente die sich auf dem Eintrag befindet welcher gerade gelöscht wird. Diese Methode erlaubt es einem Objekt von \textit{ComponentExtension} seinen Zustand aufzuräumen. Zuletzt bietet die \textit{ComponentExtension} Klasse die Hilfsmethode searchIndex(e : Entry). Diese Methode gibt den Index eines Eintrags in der Tabelle zurück und wird für das verwalten der zusätzlichen Daten in einer Erweiterung benötigt.
		\\
		Folgende Implementation der \textit{ListExtension} werden benötigt:
		\begin{itemize}
			\item[\textit{TextExtension}:] Fügt in jedem Eintrag ein JLabel ein, welches einen vordefinierten Text anzeigt. Dieser Text wird über ein Liste aus Strings in dem Konstruktor übergeben.
			\item[\textit{NumberedExtension}:] Jeder Eintrag wird von oben nach unten nummeriert.
			\item[\textit{DescriptionExtension}:] Eine Schaltfläche auf jedem Eintrag öffnet ein Dialog Fenster in dem eine Beschreibung geschrieben werden kann.
			\item[\textit{RadioSelectionExtension}:] Jeder Eintrag enthält einen Radiobutton und ist zusammen mit dem äquivalenten Radiobutton in den anderen Einträgen in einer ButtonGroup. So kann der Benutzer einen Eintrag auswählen.
			\item[\textit{TextFieldExtension}:] Ein Textfeld wird auf jedem Eintrag angezeigt.
			\item[\textit{RemovableExtension}:] Es ist möglich für den Benutzer Einträge zu löschen, indem er auf die von der Erweiterung hinzugefügten Schaltfläche drückt.
		\end{itemize}
	
		\subsection{SupervisorView}
		TODO
		
		\subsection{VoterView}
		TODO
	
	\newpage

	\section{Control}
	Der grundlegende Aufbau der Control Subpakete ist eine Control Klasse welche das entsprechende ViewToControlIF implementiert. Diese Implementation hält alle relevanten Listener welche durch die [\textit{Supervisor}|\textit{Voter}]\textit{ViewToControlIF} gefordert sind und durch die Klasse [\textit{Supervisor}|\textit{Voter}]\textit{EventListener} generalisiert sind. Diese Klasse implementiert \textit{ActionListener} und hat zugriff auf das Model und View Interface, damit es die vom Listener abhängigen Zustandsänderungen in der View oder Model anfordern kann. Jeder Listener wird einer oder mehreren Schaltflächen (i.d.R JButtons) als \textit{ActionListener} übergebeben.\\
	\\
	Für den Wahlleiter werden folgende Listener ausgelöst, wenn...
	\begin{itemize}
		\item\textit{NewConfigListener}: der Wahlleiter eine neue Wahl konfigurieren möchte.
		\item\textit{ImportConfigListener}: eine gespeicherte Wahlkonfiguration laden möchte.
		\item\textit{ExportConfigListener}: eine Wahlkonfiguration abspeichern möchte.
		\item\textit{ConfirmedConfigListener}: er eine Wahl fertig konfiguriert hat. Die Konfiguration wird daraufhin auf mögliche Probleme überprüft.
		\item\textit{FinishElectionListener}: die derzeit aktive Wahl endgültig beendet werden soll. 
		\item\textit{FirstAuthenticationListener}: er sich das erste mal in dem Netzwerk anmeldet.
		\item\textit{SupervisorAuthenticationListener}: der Wahlleiter sich mit seinem Zertifikat anmeldet.
		\item\textit{SupervisorLogoutListener}: er seinen Klient beendet.
		\item\textit{StartElectionListener}: eine Wahl aktiviert werden soll.
	\end{itemize}
	
	Für den Wähler werden folgende Listener ausgelöst, wenn...
	\begin{itemize}
		\item\textit{VoterLogout}: der Wähler seinen Klienten beendet.
		\item\textit{VoterAuthenticationListener}: er sich mit seinem Zertifikat anmeldet.
		\item\textit{VotedListener}: der Wähler seine Stimme abgeben will.
	\end{itemize}


\end{document}
